( () => {
    "use strict";
    const t = {};
    let e = {
        Android: function() {
            return navigator.userAgent.match(/Android/i)
        },
        BlackBerry: function() {
            return navigator.userAgent.match(/BlackBerry/i)
        },
        iOS: function() {
            return navigator.userAgent.match(/iPhone|iPad|iPod/i)
        },
        Opera: function() {
            return navigator.userAgent.match(/Opera Mini/i)
        },
        Windows: function() {
            return navigator.userAgent.match(/IEMobile/i)
        },
        any: function() {
            return e.Android() || e.BlackBerry() || e.iOS() || e.Opera() || e.Windows()
        }
    };
    function i() {
        if (location.hash)
            return location.hash.replace("#", "")
    }
    let s = !0
      , o = (t=500) => {
        document.documentElement.classList.contains("lock") ? n(t) : r(t)
    }
      , n = (t=500) => {
        if (s) {
            const e = document.querySelectorAll("[data-lp]");
            setTimeout(( () => {
                e.forEach((t => {
                    t.style.paddingRight = ""
                }
                )),
                document.body.style.paddingRight = "",
                document.documentElement.classList.remove("lock")
            }
            ), t),
            s = !1,
            setTimeout((function() {
                s = !0
            }
            ), t)
        }
    }
      , r = (t=500) => {
        if (s) {
            const e = document.querySelectorAll("[data-lp]")
              , i = window.innerWidth - document.body.offsetWidth + "px";
            e.forEach((t => {
                t.style.paddingRight = i
            }
            )),
            document.body.style.paddingRight = i,
            document.documentElement.classList.add("lock"),
            s = !1,
            setTimeout((function() {
                s = !0
            }
            ), t)
        }
    }
    ;
    function l() {
        n(),
        document.documentElement.classList.remove("menu-open")
    }
    function a(t) {
        setTimeout(( () => {
            window.FLS && console.log(t)
        }
        ), 0)
    }
    function c(t) {
        return t.filter((function(t, e, i) {
            return i.indexOf(t) === e
        }
        ))
    }
    if (!window.navigator.userAgent.match(/Trident\/7\./, [])) {
        const t = document.querySelectorAll("video");
        !function() {
            const t = window.navigator
              , e = t.userAgent.toLowerCase()
              , i = !(!t.mediaCapabilities || !t.mediaCapabilities.decodingInfo);
            return -1 != e.indexOf("safari") && !(-1 != e.indexOf("chrome")) && -1 != e.indexOf("version/") && i
        }() ? t.forEach((t => {
            let e = t.getAttribute("src");
            e += "webm",
            t.setAttribute("src", e)
        }
        )) : t.forEach((t => {
            let e = t.getAttribute("src");
            e += "mov",
            t.setAttribute("src", e),
            t.setAttribute("type", "video/quicktime")
        }
        ))
    }
    let h = (t, e=!1, i=500, s=0) => {
        const o = document.querySelector(t);
        if (o) {
            let n = ""
              , r = 0;
            if (e) {
                n = "header.header";
                const t = document.querySelector(n);
                t.classList.contains("_header-scroll") ? r = t.offsetHeight : (t.style.cssText = "transition-duration: 0s;",
                t.classList.add("_header-scroll"),
                r = t.offsetHeight,
                t.classList.remove("_header-scroll"),
                setTimeout(( () => {
                    t.style.cssText = ""
                }
                ), 0))
            }
            let c = {
                speedAsDuration: !0,
                speed: i,
                header: n,
                offset: s,
                easing: "easeOutQuad"
            };
            if (document.documentElement.classList.contains("menu-open") && l(),
            "undefined" != typeof SmoothScroll)
                (new SmoothScroll).animateScroll(o, "", c);
            else {
                let t = o.getBoundingClientRect().top + scrollY;
                t = r ? t - r : t,
                t = s ? t - s : t,
                window.scrollTo({
                    top: t,
                    behavior: "smooth"
                })
            }
            a(`[gotoBlock]: Юхуу...їдемо до ${t}`)
        } else
            a(`[gotoBlock]: Йой... Такого блоку немає на сторінці: ${t}`)
    }
    ;
    t.watcher = new class {
        constructor(t) {
            this.config = Object.assign({
                logging: !0
            }, t),
            this.observer,
            !document.documentElement.classList.contains("watcher") && this.scrollWatcherRun()
        }
        scrollWatcherUpdate() {
            this.scrollWatcherRun()
        }
        scrollWatcherRun() {
            document.documentElement.classList.add("watcher"),
            this.scrollWatcherConstructor(document.querySelectorAll("[data-watch]"))
        }
        scrollWatcherConstructor(t) {
            if (t.length) {
                this.scrollWatcherLogging(`Прокинувся, стежу за об'єктами (${t.length})...`),
                c(Array.from(t).map((function(t) {
                    if ("navigator" === t.dataset.watch && !t.dataset.watchThreshold) {
                        let e;
                        t.clientHeight > 2 ? (e = window.innerHeight / 2 / (t.clientHeight - 1),
                        e > 1 && (e = 1)) : e = 1,
                        t.setAttribute("data-watch-threshold", e.toFixed(2))
                    }
                    return `${t.dataset.watchRoot ? t.dataset.watchRoot : null}|${t.dataset.watchMargin ? t.dataset.watchMargin : "0px"}|${t.dataset.watchThreshold ? t.dataset.watchThreshold : 0}`
                }
                ))).forEach((e => {
                    let i = e.split("|")
                      , s = {
                        root: i[0],
                        margin: i[1],
                        threshold: i[2]
                    }
                      , o = Array.from(t).filter((function(t) {
                        let e = t.dataset.watchRoot ? t.dataset.watchRoot : null
                          , i = t.dataset.watchMargin ? t.dataset.watchMargin : "0px"
                          , o = t.dataset.watchThreshold ? t.dataset.watchThreshold : 0;
                        if (String(e) === s.root && String(i) === s.margin && String(o) === s.threshold)
                            return t
                    }
                    ))
                      , n = this.getScrollWatcherConfig(s);
                    this.scrollWatcherInit(o, n)
                }
                ))
            } else
                this.scrollWatcherLogging("Сплю, немає об'єктів для стеження. ZzzZZzz")
        }
        getScrollWatcherConfig(t) {
            let e = {};
            if (document.querySelector(t.root) ? e.root = document.querySelector(t.root) : "null" !== t.root && this.scrollWatcherLogging(`Эмм... батьківського об'єкта ${t.root} немає на сторінці`),
            e.rootMargin = t.margin,
            !(t.margin.indexOf("px") < 0 && t.margin.indexOf("%") < 0)) {
                if ("prx" === t.threshold) {
                    t.threshold = [];
                    for (let e = 0; e <= 1; e += .005)
                        t.threshold.push(e)
                } else
                    t.threshold = t.threshold.split(",");
                return e.threshold = t.threshold,
                e
            }
            this.scrollWatcherLogging("йой, налаштування data-watch-margin потрібно задавати в PX або %")
        }
        scrollWatcherCreate(t) {
            this.observer = new IntersectionObserver(( (t, e) => {
                t.forEach((t => {
                    this.scrollWatcherCallback(t, e)
                }
                ))
            }
            ),t)
        }
        scrollWatcherInit(t, e) {
            this.scrollWatcherCreate(e),
            t.forEach((t => this.observer.observe(t)))
        }
        scrollWatcherIntersecting(t, e) {
            t.isIntersecting ? (!e.classList.contains("_watcher-view") && e.classList.add("_watcher-view"),
            this.scrollWatcherLogging(`Я бачу ${e.classList}, додав клас _watcher-view`)) : (e.classList.contains("_watcher-view") && e.classList.remove("_watcher-view"),
            this.scrollWatcherLogging(`Я не бачу ${e.classList}, прибрав клас _watcher-view`))
        }
        scrollWatcherOff(t, e) {
            e.unobserve(t),
            this.scrollWatcherLogging(`Я перестав стежити за ${t.classList}`)
        }
        scrollWatcherLogging(t) {
            this.config.logging && a(`[Спостерігач]: ${t}`)
        }
        scrollWatcherCallback(t, e) {
            const i = t.target;
            this.scrollWatcherIntersecting(t, i),
            i.hasAttribute("data-watch-once") && t.isIntersecting && this.scrollWatcherOff(i, e),
            document.dispatchEvent(new CustomEvent("watcherCallback",{
                detail: {
                    entry: t
                }
            }))
        }
    }
    ({});
    let d = !1;
    function u(t, e, i) {
        return Math.max(t, Math.min(e, i))
    }
    setTimeout(( () => {
        if (d) {
            let t = new Event("windowScroll");
            window.addEventListener("scroll", (function(e) {
                document.dispatchEvent(t)
            }
            ))
        }
    }
    ), 0);
    class m {
        advance(t) {
            if (!this.isRunning)
                return;
            let e = !1;
            if (this.lerp)
                this.value = (i = this.value,
                s = this.to,
                o = 60 * this.lerp,
                n = t,
                function(t, e, i) {
                    return (1 - i) * t + i * e
                }(i, s, 1 - Math.exp(-o * n))),
                Math.round(this.value) === this.to && (this.value = this.to,
                e = !0);
            else {
                this.currentTime += t;
                const i = u(0, this.currentTime / this.duration, 1);
                e = i >= 1;
                const s = e ? 1 : this.easing(i);
                this.value = this.from + (this.to - this.from) * s
            }
            var i, s, o, n;
            this.onUpdate?.(this.value, e),
            e && this.stop()
        }
        stop() {
            this.isRunning = !1
        }
        fromTo(t, e, {lerp: i=.1, duration: s=1, easing: o=t => t, onStart: n, onUpdate: r}) {
            this.from = this.value = t,
            this.to = e,
            this.lerp = i,
            this.duration = s,
            this.easing = o,
            this.currentTime = 0,
            this.isRunning = !0,
            n?.(),
            this.onUpdate = r
        }
    }
    class p {
        constructor({wrapper: t, content: e, autoResize: i=!0, debounce: s=250}={}) {
            this.wrapper = t,
            this.content = e,
            i && (this.debouncedResize = function(t, e) {
                let i;
                return function() {
                    let s = arguments
                      , o = this;
                    clearTimeout(i),
                    i = setTimeout((function() {
                        t.apply(o, s)
                    }
                    ), e)
                }
            }(this.resize, s),
            this.wrapper === window ? window.addEventListener("resize", this.debouncedResize, !1) : (this.wrapperResizeObserver = new ResizeObserver(this.debouncedResize),
            this.wrapperResizeObserver.observe(this.wrapper)),
            this.contentResizeObserver = new ResizeObserver(this.debouncedResize),
            this.contentResizeObserver.observe(this.content)),
            this.resize()
        }
        destroy() {
            this.wrapperResizeObserver?.disconnect(),
            this.contentResizeObserver?.disconnect(),
            window.removeEventListener("resize", this.debouncedResize, !1)
        }
        resize = () => {
            this.onWrapperResize(),
            this.onContentResize()
        }
        ;
        onWrapperResize = () => {
            this.wrapper === window ? (this.width = window.innerWidth,
            this.height = window.innerHeight) : (this.width = this.wrapper.clientWidth,
            this.height = this.wrapper.clientHeight)
        }
        ;
        onContentResize = () => {
            this.wrapper === window ? (this.scrollHeight = this.content.scrollHeight,
            this.scrollWidth = this.content.scrollWidth) : (this.scrollHeight = this.wrapper.scrollHeight,
            this.scrollWidth = this.wrapper.scrollWidth)
        }
        ;
        get limit() {
            return {
                x: this.scrollWidth - this.width,
                y: this.scrollHeight - this.height
            }
        }
    }
    class g {
        constructor() {
            this.events = {}
        }
        emit(t, ...e) {
            let i = this.events[t] || [];
            for (let t = 0, s = i.length; t < s; t++)
                i[t](...e)
        }
        on(t, e) {
            return this.events[t]?.push(e) || (this.events[t] = [e]),
            () => {
                this.events[t] = this.events[t]?.filter((t => e !== t))
            }
        }
        off(t, e) {
            this.events[t] = this.events[t]?.filter((t => e !== t))
        }
        destroy() {
            this.events = {}
        }
    }
    const w = 100 / 6;
    class v {
        constructor(t, {wheelMultiplier: e=1, touchMultiplier: i=1}) {
            this.element = t,
            this.wheelMultiplier = e,
            this.touchMultiplier = i,
            this.touchStart = {
                x: null,
                y: null
            },
            this.emitter = new g,
            window.addEventListener("resize", this.onWindowResize, !1),
            this.onWindowResize(),
            this.element.addEventListener("wheel", this.onWheel, {
                passive: !1
            }),
            this.element.addEventListener("touchstart", this.onTouchStart, {
                passive: !1
            }),
            this.element.addEventListener("touchmove", this.onTouchMove, {
                passive: !1
            }),
            this.element.addEventListener("touchend", this.onTouchEnd, {
                passive: !1
            })
        }
        on(t, e) {
            return this.emitter.on(t, e)
        }
        destroy() {
            this.emitter.destroy(),
            window.removeEventListener("resize", this.onWindowResize, !1),
            this.element.removeEventListener("wheel", this.onWheel, {
                passive: !1
            }),
            this.element.removeEventListener("touchstart", this.onTouchStart, {
                passive: !1
            }),
            this.element.removeEventListener("touchmove", this.onTouchMove, {
                passive: !1
            }),
            this.element.removeEventListener("touchend", this.onTouchEnd, {
                passive: !1
            })
        }
        onTouchStart = t => {
            const {clientX: e, clientY: i} = t.targetTouches ? t.targetTouches[0] : t;
            this.touchStart.x = e,
            this.touchStart.y = i,
            this.lastDelta = {
                x: 0,
                y: 0
            },
            this.emitter.emit("scroll", {
                deltaX: 0,
                deltaY: 0,
                event: t
            })
        }
        ;
        onTouchMove = t => {
            const {clientX: e, clientY: i} = t.targetTouches ? t.targetTouches[0] : t
              , s = -(e - this.touchStart.x) * this.touchMultiplier
              , o = -(i - this.touchStart.y) * this.touchMultiplier;
            this.touchStart.x = e,
            this.touchStart.y = i,
            this.lastDelta = {
                x: s,
                y: o
            },
            this.emitter.emit("scroll", {
                deltaX: s,
                deltaY: o,
                event: t
            })
        }
        ;
        onTouchEnd = t => {
            this.emitter.emit("scroll", {
                deltaX: this.lastDelta.x,
                deltaY: this.lastDelta.y,
                event: t
            })
        }
        ;
        onWheel = t => {
            let {deltaX: e, deltaY: i, deltaMode: s} = t;
            e *= 1 === s ? w : 2 === s ? this.windowWidth : 1,
            i *= 1 === s ? w : 2 === s ? this.windowHeight : 1,
            e *= this.wheelMultiplier,
            i *= this.wheelMultiplier,
            this.emitter.emit("scroll", {
                deltaX: e,
                deltaY: i,
                event: t
            })
        }
        ;
        onWindowResize = () => {
            this.windowWidth = window.innerWidth,
            this.windowHeight = window.innerHeight
        }
    }
    class f {
        constructor({wrapper: t=window, content: e=document.documentElement, wheelEventsTarget: i=t, eventsTarget: s=i, smoothWheel: o=!0, syncTouch: n=!1, syncTouchLerp: r=.075, touchInertiaMultiplier: l=35, duration: a, easing: c=t => Math.min(1, 1.001 - Math.pow(2, -10 * t)), lerp: h=!a && .1, infinite: d=!1, orientation: u="vertical", gestureOrientation: w="vertical", touchMultiplier: f=1, wheelMultiplier: S=1, autoResize: L=!0, __experimental__naiveDimensions: y=!1}={}) {
            this.__isSmooth = !1,
            this.__isScrolling = !1,
            this.__isStopped = !1,
            this.__isLocked = !1,
            this.onVirtualScroll = ({deltaX: t, deltaY: e, event: i}) => {
                if (i.ctrlKey)
                    return;
                const s = i.type.includes("touch")
                  , o = i.type.includes("wheel");
                if (this.options.syncTouch && s && "touchstart" === i.type && !this.isStopped && !this.isLocked)
                    return void this.reset();
                const n = 0 === t && 0 === e
                  , r = "vertical" === this.options.gestureOrientation && 0 === e || "horizontal" === this.options.gestureOrientation && 0 === t;
                if (n || r)
                    return;
                let l = i.composedPath();
                if (l = l.slice(0, l.indexOf(this.rootElement)),
                l.find((t => {
                    var e, i, n, r, l;
                    return (null === (e = t.hasAttribute) || void 0 === e ? void 0 : e.call(t, "data-lenis-prevent")) || s && (null === (i = t.hasAttribute) || void 0 === i ? void 0 : i.call(t, "data-lenis-prevent-touch")) || o && (null === (n = t.hasAttribute) || void 0 === n ? void 0 : n.call(t, "data-lenis-prevent-wheel")) || (null === (r = t.classList) || void 0 === r ? void 0 : r.contains("lenis")) && !(null === (l = t.classList) || void 0 === l ? void 0 : l.contains("lenis-stopped"))
                }
                )))
                    return;
                if (this.isStopped || this.isLocked)
                    return void i.preventDefault();
                if (this.isSmooth = this.options.syncTouch && s || this.options.smoothWheel && o,
                !this.isSmooth)
                    return this.isScrolling = !1,
                    void this.animate.stop();
                i.preventDefault();
                let a = e;
                "both" === this.options.gestureOrientation ? a = Math.abs(e) > Math.abs(t) ? e : t : "horizontal" === this.options.gestureOrientation && (a = t);
                const c = s && this.options.syncTouch
                  , h = s && "touchend" === i.type && Math.abs(a) > 5;
                h && (a = this.velocity * this.options.touchInertiaMultiplier),
                this.scrollTo(this.targetScroll + a, Object.assign({
                    programmatic: !1
                }, c ? {
                    lerp: h ? this.options.syncTouchLerp : 1
                } : {
                    lerp: this.options.lerp,
                    duration: this.options.duration,
                    easing: this.options.easing
                }))
            }
            ,
            this.onNativeScroll = () => {
                if (!this.__preventNextScrollEvent && !this.isScrolling) {
                    const t = this.animatedScroll;
                    this.animatedScroll = this.targetScroll = this.actualScroll,
                    this.velocity = 0,
                    this.direction = Math.sign(this.animatedScroll - t),
                    this.emit()
                }
            }
            ,
            window.lenisVersion = "1.0.42",
            t !== document.documentElement && t !== document.body || (t = window),
            this.options = {
                wrapper: t,
                content: e,
                wheelEventsTarget: i,
                eventsTarget: s,
                smoothWheel: o,
                syncTouch: n,
                syncTouchLerp: r,
                touchInertiaMultiplier: l,
                duration: a,
                easing: c,
                lerp: h,
                infinite: d,
                gestureOrientation: w,
                orientation: u,
                touchMultiplier: f,
                wheelMultiplier: S,
                autoResize: L,
                __experimental__naiveDimensions: y
            },
            this.animate = new m,
            this.emitter = new g,
            this.dimensions = new p({
                wrapper: t,
                content: e,
                autoResize: L
            }),
            this.toggleClassName("lenis", !0),
            this.velocity = 0,
            this.isLocked = !1,
            this.isStopped = !1,
            this.isSmooth = n || o,
            this.isScrolling = !1,
            this.targetScroll = this.animatedScroll = this.actualScroll,
            this.options.wrapper.addEventListener("scroll", this.onNativeScroll, !1),
            this.virtualScroll = new v(s,{
                touchMultiplier: f,
                wheelMultiplier: S
            }),
            this.virtualScroll.on("scroll", this.onVirtualScroll)
        }
        destroy() {
            this.emitter.destroy(),
            this.options.wrapper.removeEventListener("scroll", this.onNativeScroll, !1),
            this.virtualScroll.destroy(),
            this.dimensions.destroy(),
            this.toggleClassName("lenis", !1),
            this.toggleClassName("lenis-smooth", !1),
            this.toggleClassName("lenis-scrolling", !1),
            this.toggleClassName("lenis-stopped", !1),
            this.toggleClassName("lenis-locked", !1)
        }
        on(t, e) {
            return this.emitter.on(t, e)
        }
        off(t, e) {
            return this.emitter.off(t, e)
        }
        setScroll(t) {
            this.isHorizontal ? this.rootElement.scrollLeft = t : this.rootElement.scrollTop = t
        }
        resize() {
            this.dimensions.resize()
        }
        emit() {
            this.emitter.emit("scroll", this)
        }
        reset() {
            this.isLocked = !1,
            this.isScrolling = !1,
            this.animatedScroll = this.targetScroll = this.actualScroll,
            this.velocity = 0,
            this.animate.stop()
        }
        start() {
            this.isStopped && (this.isStopped = !1,
            this.reset())
        }
        stop() {
            this.isStopped || (this.isStopped = !0,
            this.animate.stop(),
            this.reset())
        }
        raf(t) {
            const e = t - (this.time || t);
            this.time = t,
            this.animate.advance(.001 * e)
        }
        scrollTo(t, {offset: e=0, immediate: i=!1, lock: s=!1, duration: o=this.options.duration, easing: n=this.options.easing, lerp: r=!o && this.options.lerp, onComplete: l, force: a=!1, programmatic: c=!0}={}) {
            if (!this.isStopped && !this.isLocked || a) {
                if (["top", "left", "start"].includes(t))
                    t = 0;
                else if (["bottom", "right", "end"].includes(t))
                    t = this.limit;
                else {
                    let i;
                    if ("string" == typeof t ? i = document.querySelector(t) : (null == t ? void 0 : t.nodeType) && (i = t),
                    i) {
                        if (this.options.wrapper !== window) {
                            const t = this.options.wrapper.getBoundingClientRect();
                            e -= this.isHorizontal ? t.left : t.top
                        }
                        const s = i.getBoundingClientRect();
                        t = (this.isHorizontal ? s.left : s.top) + this.animatedScroll
                    }
                }
                if ("number" == typeof t) {
                    if (t += e,
                    t = Math.round(t),
                    this.options.infinite ? c && (this.targetScroll = this.animatedScroll = this.scroll) : t = u(0, t, this.limit),
                    i)
                        return this.animatedScroll = this.targetScroll = t,
                        this.setScroll(this.scroll),
                        this.reset(),
                        void (null == l || l(this));
                    if (!c) {
                        if (t === this.targetScroll)
                            return;
                        this.targetScroll = t
                    }
                    this.animate.fromTo(this.animatedScroll, t, {
                        duration: o,
                        easing: n,
                        lerp: r,
                        onStart: () => {
                            s && (this.isLocked = !0),
                            this.isScrolling = !0
                        }
                        ,
                        onUpdate: (t, e) => {
                            this.isScrolling = !0,
                            this.velocity = t - this.animatedScroll,
                            this.direction = Math.sign(this.velocity),
                            this.animatedScroll = t,
                            this.setScroll(this.scroll),
                            c && (this.targetScroll = t),
                            e || this.emit(),
                            e && (this.reset(),
                            this.emit(),
                            null == l || l(this),
                            this.__preventNextScrollEvent = !0,
                            requestAnimationFrame(( () => {
                                delete this.__preventNextScrollEvent
                            }
                            )))
                        }
                    })
                }
            }
        }
        get rootElement() {
            return this.options.wrapper === window ? document.documentElement : this.options.wrapper
        }
        get limit() {
            return this.options.__experimental__naiveDimensions ? this.isHorizontal ? this.rootElement.scrollWidth - this.rootElement.clientWidth : this.rootElement.scrollHeight - this.rootElement.clientHeight : this.dimensions.limit[this.isHorizontal ? "x" : "y"]
        }
        get isHorizontal() {
            return "horizontal" === this.options.orientation
        }
        get actualScroll() {
            return this.isHorizontal ? this.rootElement.scrollLeft : this.rootElement.scrollTop
        }
        get scroll() {
            return this.options.infinite ? (this.animatedScroll % (t = this.limit) + t) % t : this.animatedScroll;
            var t
        }
        get progress() {
            return 0 === this.limit ? 1 : this.scroll / this.limit
        }
        get isSmooth() {
            return this.__isSmooth
        }
        set isSmooth(t) {
            this.__isSmooth !== t && (this.__isSmooth = t,
            this.toggleClassName("lenis-smooth", t))
        }
        get isScrolling() {
            return this.__isScrolling
        }
        set isScrolling(t) {
            this.__isScrolling !== t && (this.__isScrolling = t,
            this.toggleClassName("lenis-scrolling", t))
        }
        get isStopped() {
            return this.__isStopped
        }
        set isStopped(t) {
            this.__isStopped !== t && (this.__isStopped = t,
            this.toggleClassName("lenis-stopped", t))
        }
        get isLocked() {
            return this.__isLocked
        }
        set isLocked(t) {
            this.__isLocked !== t && (this.__isLocked = t,
            this.toggleClassName("lenis-locked", t))
        }
        get className() {
            let t = "lenis";
            return this.isStopped && (t += " lenis-stopped"),
            this.isLocked && (t += " lenis-locked"),
            this.isScrolling && (t += " lenis-scrolling"),
            this.isSmooth && (t += " lenis-smooth"),
            t
        }
        toggleClassName(t, e) {
            this.rootElement.classList.toggle(t, e),
            this.emitter.emit("className change", this)
        }
    }
    window.onRefreshLenisScroll = () => {
        window.lenis?.destroy(),
        setTimeout(( () => {
            window.lenis = new f({
                eventsTarget: document.querySelector("main"),
                duration: 1.2,
                infinite: !1,
                autoResize: !0
            }),
            requestAnimationFrame((function t(e) {
                window.lenis.raf(e),
                requestAnimationFrame(t)
            }
            ))
        }
        ), 0)
    }
    ,
    !e.any() && window.onRefreshLenisScroll(),
    document.documentElement.classList.contains("loading") || window.addEventListener("load", (function() {
        setTimeout((function() {
            document.documentElement.classList.add("loaded")
        }
        ), 0)
    }
    )),
    document.querySelector(".icon-menu") && document.addEventListener("click", (function(t) {
        s && t.target.closest(".icon-menu") && (o(),
        document.documentElement.classList.toggle("menu-open"))
    }
    )),
    function() {
        const t = document.querySelectorAll("[data-clipboardBtn]");
        t.length && t.forEach((t => {
            t.addEventListener("click", ( () => {
                const e = t.closest("[data-clipboard]");
                if (e) {
                    const i = e.querySelector("[data-clipboardEl]").textContent.trim()
                      , s = e.querySelector("[data-cnHint]");
                    async function o(t) {
                        try {
                            await navigator.clipboard.writeText(t)
                        } catch (t) {
                            s.textContent = "Doesn't copied"
                        } finally {
                            setTimeout(( () => {
                                e.classList.remove("active")
                            }
                            ), 1e3)
                        }
                    }
                    e.classList.add("active"),
                    o(i)
                }
            }
            ))
        }
        ))
    }(),
    function() {
        function e(e) {
            if ("click" === e.type) {
                const i = e.target;
                if (i.closest("[data-goto]")) {
                    const s = i.closest("[data-goto]")
                      , o = s.dataset.goto ? s.dataset.goto : ""
                      , n = !!s.hasAttribute("data-goto-header")
                      , r = s.dataset.gotoSpeed ? s.dataset.gotoSpeed : 500
                      , a = s.dataset.gotoTop ? parseInt(s.dataset.gotoTop) : 0;
                    if (t.fullpage) {
                        const e = document.querySelector(`${o}`).closest("[data-fp-section]")
                          , i = e ? +e.dataset.fpId : null;
                        null !== i && (t.fullpage.switchingSection(i),
                        document.documentElement.classList.contains("menu-open") && l())
                    } else
                        h(o, n, r, a);
                    e.preventDefault()
                }
            } else if ("watcherCallback" === e.type && e.detail) {
                const t = e.detail.entry
                  , i = t.target;
                if ("navigator" === i.dataset.watch) {
                    document.querySelector("[data-goto]._navigator-active");
                    let e;
                    if (i.id && document.querySelector(`[data-goto="#${i.id}"]`))
                        e = document.querySelector(`[data-goto="#${i.id}"]`);
                    else if (i.classList.length)
                        for (let t = 0; t < i.classList.length; t++) {
                            const s = i.classList[t];
                            if (document.querySelector(`[data-goto=".${s}"]`)) {
                                e = document.querySelector(`[data-goto=".${s}"]`);
                                break
                            }
                        }
                    t.isIntersecting ? e && e.classList.add("_navigator-active") : e && e.classList.remove("_navigator-active")
                }
            }
        }
        if (document.addEventListener("click", e),
        document.addEventListener("watcherCallback", e),
        i()) {
            let t;
            document.querySelector(`#${i()}`) ? t = `#${i()}` : document.querySelector(`.${i()}`) && (t = `.${i()}`),
            t && h(t, !0, 500, 20)
        }
    }(),
    function() {
        d = !0;
        const t = document.querySelector("header.header")
          , e = t.hasAttribute("data-scroll-show")
          , i = t.dataset.scrollShow ? t.dataset.scrollShow : 500
          , s = t.dataset.scroll ? t.dataset.scroll : 1;
        let o, n = 0;
        document.addEventListener("windowScroll", (function(r) {
            const l = window.scrollY;
            clearTimeout(o),
            l >= s ? (!t.classList.contains("_header-scroll") && t.classList.add("_header-scroll"),
            e && (l > n ? t.classList.contains("_header-show") && t.classList.remove("_header-show") : !t.classList.contains("_header-show") && t.classList.add("_header-show"),
            o = setTimeout(( () => {
                !t.classList.contains("_header-show") && t.classList.add("_header-show")
            }
            ), i))) : (t.classList.contains("_header-scroll") && t.classList.remove("_header-scroll"),
            e && t.classList.contains("_header-show") && t.classList.remove("_header-show")),
            n = l <= 0 ? 0 : l
        }
        ))
    }()
}
)();
